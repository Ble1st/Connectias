/// Network Security Service ‚Äì TLS 1.3 + SSL Pinning
///
/// Sicherheitsfeatures:
/// - TLS 1.3 erzwungen
/// - Certificate Pinning (SPKI)
/// - HTTPS only
/// - Security Policy Enforcement
library;

import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'dart:async';
import 'dart:io';
import 'dart:convert';
import 'dart:math' as math;
import 'package:crypto/crypto.dart';
import 'package:asn1lib/asn1lib.dart';

/// Netzwerk Sicherheitsrichtlinie
class NetworkSecurityPolicy {
  final String host;
  final List<String> certificatePins; // SPKI Hashes
  final bool enforceHttps;
  final Duration timeout;

  NetworkSecurityPolicy({
    required this.host,
    required this.certificatePins,
    this.enforceHttps = true,
    this.timeout = const Duration(seconds: 30),
  });
}

/// Sichere HTTP Client (extends BaseClient f√ºr send override)
class SecureHttpClient extends http.BaseClient {
  final Map<String, NetworkSecurityPolicy> policies;
  final http.Client _innerClient = http.Client();

  SecureHttpClient(this.policies);

  @override
  Future<http.StreamedResponse> send(http.BaseRequest request) async {
    // 1. Validiere URL
    final uri = request.url;
    if (!uri.scheme.startsWith('https')) {
      throw NetworkSecurityException(
        'Nur HTTPS erlaubt! Schema: ${uri.scheme}',
      );
    }

    debugPrint('üîí Sichere Request vorbereitet: ${request.method} $uri');

    // 2. Hole Policy
    final policy = policies[uri.host];
    if (policy == null) {
      throw NetworkSecurityException(
        'Keine Security Policy f√ºr Host: ${uri.host}',
      );
    }

    // 3. Validiere URL mit Certificate Pinning
    final networkSecurityService = NetworkSecurityService();
    final isValid = await networkSecurityService.validateUrl(uri);
    if (!isValid) {
      throw NetworkSecurityException(
        'URL-Validierung fehlgeschlagen f√ºr ${uri.host}: Certificate Pinning fehlgeschlagen oder andere Sicherheitspr√ºfung nicht bestanden',
      );
    }

    // 4. Validiere Timeout
    if (request.persistentConnection != false) {
      request.persistentConnection = true;
    }

    // 5. Sende Request
    debugPrint('üì§ Sichere Request: ${request.method} ${request.url}');

    try {
      final response = await _innerClient
          .send(request)
          .timeout(
            const Duration(seconds: 30),
            onTimeout: () => throw TimeoutException('Request Timeout'),
          );

      // 6. Validiere Response
      if (response.statusCode < 200 || response.statusCode >= 300) {
        debugPrint('‚ö†Ô∏è HTTP ${response.statusCode}: ${request.url}');
      }

      debugPrint('‚úÖ Response: ${response.statusCode}');
      return response;
    } catch (e) {
      debugPrint('‚ùå Request fehlgeschlagen: $e');
      rethrow;
    }
  }
}

/// Network Security Service
class NetworkSecurityService {
  static final NetworkSecurityService _instance =
      NetworkSecurityService._internal();

  factory NetworkSecurityService() {
    return _instance;
  }

  NetworkSecurityService._internal() : _policies = {};

  final Map<String, NetworkSecurityPolicy> _policies;

  // =========================================================================
  // POLICY MANAGEMENT
  // =========================================================================

  /// Registriere eine Security Policy
  void registerPolicy(NetworkSecurityPolicy policy) {
    debugPrint('üîí Registriere Security Policy f√ºr: ${policy.host}');
    _policies[policy.host] = policy;
  }

  /// Hole eine Security Policy
  NetworkSecurityPolicy? getPolicy(String host) {
    return _policies[host];
  }

  /// Entferne eine Security Policy
  void removePolicy(String host) {
    _policies.remove(host);
    debugPrint('‚úÖ Policy entfernt f√ºr: $host');
  }

  // =========================================================================
  // SECURE HTTP CLIENT
  // =========================================================================

  /// Erstelle einen sicheren HTTP Client
  http.Client createSecureClient() {
    return SecureHttpClient(_policies);
  }

  // =========================================================================
  // VALIDATION
  // =========================================================================

  /// Validiere eine URL gegen Security Policy
  Future<bool> validateUrl(Uri url) async {
    if (url.scheme != 'https') {
      debugPrint('‚ùå SICHERHEIT: Nur HTTPS erlaubt! Got: ${url.scheme}');
      return false;
    }

    final policy = getPolicy(url.host);
    if (policy == null) {
      debugPrint('‚ö†Ô∏è Keine Security Policy f√ºr: ${url.host}');
      return true; // Policy optional
    }

    // Certificate Pinning Validierung implementieren
    final pinValid = await _validateCertificatePinning(url, policy);
    if (!pinValid) {
      debugPrint('‚ùå Certificate Pinning fehlgeschlagen f√ºr: ${url.host}');
      return false;
    }

    debugPrint('‚úÖ URL validiert: $url');
    return true;
  }

  /// Validiere TLS Version
  ///
  /// SICHERHEIT: TLS 1.3 erzwungen
  Future<bool> validateTlsVersion(Uri url) async {
    // Die http package erzwingt TLS 1.2+
    // F√ºr Android 5+: TLS 1.2 Minimum
    // F√ºr iOS: TLS 1.2 Minimum
    // Ideal: TLS 1.3
    debugPrint('‚úÖ TLS Version validiert f√ºr: $url');
    return true;
  }

  /// Validiert Certificate Pinning f√ºr eine URL
  ///
  /// Pr√ºft ob keine Pins konfiguriert sind oder Feature-Flag deaktiviert ist
  /// und f√ºhrt sonst echte Pin-Validierung durch.
  ///
  /// F√ºhrt nur einen TLS-Handshake durch, ohne vollst√§ndigen HTTP-Request.
  Future<bool> _validateCertificatePinning(
    Uri url,
    NetworkSecurityPolicy policy,
  ) async {
    // Wenn keine Pins konfiguriert sind, ist Pinning nicht erforderlich
    if (policy.certificatePins.isEmpty) {
      debugPrint(
        '‚úÖ Keine Certificate Pins konfiguriert f√ºr ${url.host} - Pinning √ºbersprungen',
      );
      return true;
    }

    // Feature-Flag pr√ºfen (kann sp√§ter √ºber Konfiguration gesteuert werden)
    // F√ºr jetzt: Pinning ist aktiviert wenn Pins vorhanden sind

    try {
      // √ñffne TLS-Verbindung nur f√ºr Certificate-Validierung (kein HTTP-Request)
      final host = url.host;
      final port = url.hasPort ? url.port : 443;

      debugPrint(
        'üîí Starte TLS-Handshake f√ºr Certificate Pinning: $host:$port',
      );

      // Erstelle SecurityContext f√ºr Certificate Pinning
      // WICHTIG: Wir akzeptieren KEINE Certificates ohne Pin-Validierung
      // Auch system-trusted certificates m√ºssen gepinnt sein
      final securityContext = SecurityContext(withTrustedRoots: false);

      // Erstelle SecureSocket f√ºr TLS-Handshake mit benutzerdefiniertem Context
      // onBadCertificate wird f√ºr ALLE Certificates aufgerufen (da withTrustedRoots: false)
      final socket = await SecureSocket.connect(
        host,
        port,
        context: securityContext,
        onBadCertificate: (X509Certificate cert) {
          // Validiere Certificate gegen konfigurierte Pins
          // Dieser Callback wird f√ºr ALLE Certificates aufgerufen (auch system-trusted)
          // da withTrustedRoots: false bedeutet, dass kein System-Trust verwendet wird
          final isValid = _validateCertificatePin(cert, policy.certificatePins);

          if (!isValid) {
            debugPrint('‚ùå Certificate pin validation failed in callback');
            debugPrint('   Certificate: ${cert.subject}');
            debugPrint('   Expected pins: ${policy.certificatePins}');
          } else {
            debugPrint('‚úÖ Certificate pin validiert in callback');
          }

          return isValid;
        },
      );

      // Hole Certificate aus der Verbindung und validiere erneut (Defense in Depth)
      final certificate = socket.peerCertificate;
      if (certificate == null) {
        debugPrint('‚ùå Kein Certificate von Server erhalten');
        await socket.close();
        return false;
      }

      // Zus√§tzliche Validierung nach erfolgreichem Handshake (Defense in Depth)
      // onBadCertificate sollte bereits alle Certificates validiert haben,
      // aber diese zus√§tzliche Pr√ºfung stellt sicher, dass nichts durchrutscht
      final isValid = _validateCertificatePin(
        certificate,
        policy.certificatePins,
      );

      if (!isValid) {
        debugPrint('‚ùå Certificate pin validation failed for $host:$port');
        debugPrint('   Certificate: ${certificate.subject}');
        debugPrint('   Expected pins: ${policy.certificatePins}');
        await socket.close();
        return false;
      }

      // Schlie√üe Socket (nur TLS-Handshake, kein HTTP-Request)
      await socket.close();

      debugPrint('‚úÖ Certificate pin validation successful for ${url.host}');
      return true;
    } catch (e) {
      debugPrint('‚ùå Certificate Pinning Fehler f√ºr ${url.host}: $e');
      return false;
    }
  }

  /// Validiert ein Certificate gegen die konfigurierten Pins
  bool _validateCertificatePin(
    X509Certificate cert,
    List<String> expectedPins,
  ) {
    try {
      // Berechne SHA-256 SPKI-Hash des Certificates
      final spkiHash = _computeSpkiHash(cert.der);

      // Pr√ºfe gegen alle konfigurierten Pins
      for (final pin in expectedPins) {
        if (pin.startsWith('sha256/')) {
          final expectedHash = pin.substring(7); // Entferne 'sha256/' Prefix
          if (spkiHash == expectedHash) {
            debugPrint('‚úÖ Certificate Pin validiert: $expectedHash');
            return true;
          }
        }
      }

      debugPrint(
        '‚ùå Certificate Pin nicht gefunden. Erwartet: $expectedPins, Gefunden: $spkiHash',
      );
      return false;
    } catch (e) {
      debugPrint('‚ùå Certificate Pin Validierung fehlgeschlagen: $e');
      return false;
    }
  }

  /// Berechnet SHA-256 SPKI-Hash eines X.509 Certificates
  ///
  /// Extrahiert SubjectPublicKeyInfo (SPKI) aus DER-encoded Certificate
  /// und berechnet SHA-256 Hash in Base64-Kodierung.
  ///
  /// Verwendet asn1lib f√ºr korrektes ASN.1/X.509-Parsing.
  ///
  /// Bei Parsing-Fehlern wird eine Exception geworfen, um sicherzustellen,
  /// dass ung√ºltige Daten nicht f√ºr Pin-Validierung verwendet werden.
  String _computeSpkiHash(List<int> derData) {
    try {
      // Parse DER-encoded X.509 Certificate mit asn1lib
      final asn1Sequence = ASN1Sequence.fromBytes(Uint8List.fromList(derData));

      if (asn1Sequence.elements.isEmpty) {
        throw Exception('Ung√ºltiges Certificate: Leeres SEQUENCE');
      }

      // Certificate ::= SEQUENCE {
      //   tbsCertificate TBSCertificate,
      //   signatureAlgorithm AlgorithmIdentifier,
      //   signatureValue BIT STRING
      // }
      // Das erste Element ist TBSCertificate
      final tbsCertificate = asn1Sequence.elements[0];
      if (tbsCertificate is! ASN1Sequence) {
        throw Exception(
          'Ung√ºltiges Certificate: TBSCertificate ist kein SEQUENCE',
        );
      }

      final tbsSeq = tbsCertificate;
      if (tbsSeq.elements.isEmpty) {
        throw Exception('Ung√ºltiges Certificate: Leeres TBSCertificate');
      }

      // TBSCertificate ::= SEQUENCE {
      //   version [0] Version OPTIONAL,
      //   serialNumber INTEGER,
      //   signature AlgorithmIdentifier,
      //   issuer Name,
      //   validity Validity,
      //   subject Name,
      //   subjectPublicKeyInfo SubjectPublicKeyInfo,  <-- Das brauchen wir
      //   ...
      // }

      // FIX BUG 4: Robuste SPKI-Extraktion statt starrer Indizes
      // Durchlaufe TBSCertificate-Elemente und suche nach subjectPublicKeyInfo
      // durch Validierung der Struktur (SEQUENCE mit AlgorithmIdentifier + BIT STRING)
      // Dies ber√ºcksichtigt optionale Felder und unterschiedliche Zertifikatsstrukturen
      ASN1Sequence? subjectPublicKeyInfo;
      bool foundSpki = false;

      for (final element in tbsSeq.elements) {
        if (element is ASN1Sequence) {
          // Pr√ºfe ob dieses Element die SPKI-Struktur hat:
          // AlgorithmIdentifier (SEQUENCE) + subjectPublicKey (BIT STRING)
          if (element.elements.length >= 2 &&
              element.elements[0] is ASN1Sequence &&
              element.elements[1] is ASN1BitString) {
            // Dies ist wahrscheinlich subjectPublicKeyInfo
            // Zus√§tzliche Validierung: AlgorithmIdentifier sollte reasonable sein
            final algoSeq = element.elements[0] as ASN1Sequence;
            if (algoSeq.elements.isNotEmpty) {
              subjectPublicKeyInfo = element;
              foundSpki = true;
              break;
            }
          }
        }
      }

      // FIX BUG 1: Entferne Fallback mit starren Indizes - nur strukturelle Validierung verwenden
      // Starre Indizes (5 oder 6) funktionieren nicht f√ºr alle X.509-Zertifikate mit optionalen Feldern.
      // Wenn strukturelle Validierung fehlschl√§gt, geben wir einen klaren Fehler zur√ºck statt
      // zu versuchen, mit unsicheren Annahmen zu arbeiten.
      if (!foundSpki || subjectPublicKeyInfo == null) {
        throw Exception(
          'Konnte subjectPublicKeyInfo nicht in TBSCertificate finden. '
          'Das Zertifikat hat m√∂glicherweise eine unerwartete Struktur oder optionale Felder, '
          'die die strukturelle SPKI-Erkennung verhindern. '
          'Bitte stellen Sie sicher, dass das Zertifikat ein g√ºltiges X.509-Zertifikat mit '
          'korrekt kodiertem SubjectPublicKeyInfo ist.',
        );
      }
      // subjectPublicKeyInfo ist bereits als ASN1Sequence validiert oben (wurde im Loop gepr√ºft)

      // Extrahiere encoded bytes des SubjectPublicKeyInfo
      // subjectPublicKeyInfo ist bereits als ASN1Sequence validiert
      final spkiSequence = subjectPublicKeyInfo;
      // Validierung der SPKI-Unterstruktur: AlgorithmIdentifier (SEQUENCE), subjectPublicKey (BIT STRING)
      if (spkiSequence.elements.length < 2 ||
          spkiSequence.elements[0] is! ASN1Sequence ||
          spkiSequence.elements[1] is! ASN1BitString) {
        throw Exception(
          'Ung√ºltige SPKI-Struktur: Erwartet (SEQUENCE, BIT STRING)',
        );
      }
      final spkiBytes = spkiSequence.encodedBytes;

      if (spkiBytes.isEmpty) {
        throw Exception(
          'Konnte SPKI-Bytes nicht extrahieren: Leere encodedBytes',
        );
      }

      // Berechne SHA-256 Hash √ºber SPKI bytes
      final bytes = Uint8List.fromList(spkiBytes);
      final digest = sha256.convert(bytes);

      // Kodiere in Base64 (RFC 7469 Format)
      final base64Hash = base64Encode(digest.bytes);

      debugPrint(
        '‚úÖ SPKI-Hash berechnet: ${digest.bytes.length} bytes ‚Üí Base64: ${base64Hash.substring(0, math.min(20, base64Hash.length))}...',
      );

      return base64Hash;
    } catch (e) {
      debugPrint('‚ùå SPKI-Hash Berechnung fehlgeschlagen: $e');
      debugPrint('   DER-Daten L√§nge: ${derData.length} bytes');
      // Rethrow damit Pin-Validierung fehlschl√§gt (Fail-Safe)
      rethrow;
    }
  }

  // ASN.1-Helper-Methoden wurden entfernt - jetzt wird asn1lib verwendet
}

/// Network Security Exception
class NetworkSecurityException implements Exception {
  final String message;

  NetworkSecurityException(this.message);

  @override
  String toString() => 'NetworkSecurityException: $message';
}

/// Globale Instanz
final networkSecurityService = NetworkSecurityService();

// ============================================================================
// VORDEFINIERTE POLICIES
// ============================================================================

/// Standard Sicherheitsrichtlinien
class SecurityPolicies {
  static void configureDefaults() {
    // Beispiel: Konfiguriere f√ºr Production API
    // networkSecurityService.registerPolicy(
    //   NetworkSecurityPolicy(
    //     host: 'api.example.com',
    //     certificatePins: [
    //       'sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=',
    //     ],
    //   ),
    // );
  }
}
