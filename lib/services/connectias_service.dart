/// Connectias Service ‚Äì High-Level Dart API
///
/// Sichere Wrapper um FFI Bridge mit automatischem Cleanup,
/// Error Handling, und Lifecycle Management.
library;

import 'package:flutter/foundation.dart';
import '../ffi/connectias_bindings.dart' as ffi;
import '../models/plugin_model.dart';

/// Connectias Plugin Manager Service
///
/// Beispiel:
/// ```dart
/// final service = ConnectiasService();
/// await service.init();
///
/// try {
///   final pluginId = await service.loadPlugin('/path/to/plugin.wasm');
///   final result = await service.executePlugin(pluginId, 'myCommand', {});
///   print('Result: $result');
/// } finally {
///   await service.dispose();
/// }
/// ```
class ConnectiasService extends ChangeNotifier {
  static final ConnectiasService _instance = ConnectiasService._internal();

  factory ConnectiasService() {
    return _instance;
  }

  ConnectiasService._internal();

  bool _initialized = false;
  final Set<String> _loadedPlugins = {};
  final Map<String, dynamic> _pluginMetadata = {};

  // =========================================================================
  // LIFECYCLE
  // =========================================================================

  /// Initialisiere den Service
  Future<void> init() async {
    if (_initialized) {
      debugPrint('‚ö†Ô∏è ConnectiasService bereits initialisiert');
      return;
    }

    try {
      debugPrint('üöÄ Initialisiere ConnectiasService...');

      // Initialisiere FFI Bridge
      await ffi.init();

      // Hole Version
      final version = ffi.getVersion();
      debugPrint('‚úÖ FFI Version: $version');

      // Hole System Info
      final systemInfo = ffi.getSystemInfo();
      debugPrint('‚úÖ System Info: $systemInfo');

      // Pr√ºfe RASP auf Sicherheitsbedrohungen
      await _checkSecurity();

      _initialized = true;
      debugPrint('‚úÖ ConnectiasService initialisiert');
      notifyListeners();
    } catch (e) {
      debugPrint('‚ùå Initialisierung fehlgeschlagen: $e');
      rethrow;
    }
  }

  /// Pr√ºfe Sicherheitsbedrohungen
  Future<void> _checkSecurity() async {
    try {
      final status = await ffi.getRaspStatus();
      debugPrint('üõ°Ô∏è RASP Status: $status');

      if (status.isCompromised) {
        throw ConnectiasSecurityException('Ger√§t ist kompromittiert!', status);
      }

      if (status.isSuspicious) {
        debugPrint('‚ö†Ô∏è WARNUNG: Verd√§chtige Aktivit√§ten erkannt!');
      }
    } catch (e) {
      debugPrint('‚ùå Security Check fehlgeschlagen: $e');
      rethrow;
    }
  }

  /// Pr√ºfe ob initialisiert
  void _requireInitialized() {
    if (!_initialized) {
      throw StateError(
        'ConnectiasService nicht initialisiert. Rufe init() auf!',
      );
    }
  }

  /// Cleanup
  @override
  Future<void> dispose() async {
    debugPrint('üßπ Cleanup ConnectiasService...');

    // Entlade alle Plugins
    for (final pluginId in List.from(_loadedPlugins)) {
      try {
        await unloadPlugin(pluginId);
      } catch (e) {
        debugPrint('‚ö†Ô∏è Fehler beim Unload von $pluginId: $e');
      }
    }

    _initialized = false;
    _loadedPlugins.clear();
    _pluginMetadata.clear();

    debugPrint('‚úÖ Cleanup fertig');
    notifyListeners();
    super.dispose();
  }

  // =========================================================================
  // PLUGIN MANAGEMENT
  // =========================================================================

  /// Lade ein Plugin
  Future<String> loadPlugin(String pluginPath) async {
    _requireInitialized();

    debugPrint('üì¶ Lade Plugin: $pluginPath');

    try {
      final pluginId = await ffi.loadPlugin(pluginPath);
      _loadedPlugins.add(pluginId);
      _pluginMetadata[pluginId] = {
        'path': pluginPath,
        'loadedAt': DateTime.now(),
      };

      debugPrint('‚úÖ Plugin geladen: $pluginId');
      notifyListeners();
      return pluginId;
    } catch (e) {
      debugPrint('‚ùå Plugin-Loading fehlgeschlagen: $e');
      rethrow;
    }
  }

  /// Entlade ein Plugin
  Future<void> unloadPlugin(String pluginId) async {
    _requireInitialized();

    debugPrint('üîå Entlade Plugin: $pluginId');

    try {
      await ffi.unloadPlugin(pluginId);
      _loadedPlugins.remove(pluginId);
      _pluginMetadata.remove(pluginId);

      debugPrint('‚úÖ Plugin entladen: $pluginId');
      notifyListeners();
    } catch (e) {
      debugPrint('‚ùå Plugin-Entladung fehlgeschlagen: $e');
      rethrow;
    }
  }

  /// F√ºhre ein Plugin aus
  Future<T> executePlugin<T>(
    String pluginId,
    String command,
    Map<String, String> args, {
    T Function(String)? parser,
  }) async {
    _requireInitialized();

    if (!_loadedPlugins.contains(pluginId)) {
      throw StateError('Plugin $pluginId nicht geladen');
    }

    debugPrint('‚öôÔ∏è F√ºhre aus: $pluginId::$command');

    try {
      final result = await ffi.executePlugin(pluginId, command, args);

      debugPrint('‚úÖ Ausf√ºhrung erfolgreich: $pluginId::$command');

      if (parser != null) {
        return parser(result);
      }

      return result as T;
    } catch (e) {
      debugPrint('‚ùå Ausf√ºhrung fehlgeschlagen: $e');
      rethrow;
    }
  }

  /// Liste alle Plugins auf
  Future<List<String>> listPlugins() async {
    _requireInitialized();

    return List.from(_loadedPlugins);
  }

  /// Hole Plugins als PluginModel Liste
  Future<List<PluginModel>> fetchPlugins() async {
    _requireInitialized();

    final pluginIds = await listPlugins();
    return pluginIds.map((id) {
      final metadata = getPluginMetadata(id);
      return PluginModel(
        id: id,
        name: metadata?['name'] ?? id,
        version: metadata?['version'] ?? '1.0.0',
        author: metadata?['author'] ?? 'Unknown',
        category: metadata?['category'] ?? 'General',
        description: metadata?['description'] ?? 'No description',
        status: PluginStatus.active,
        permissions: List<String>.from(metadata?['permissions'] ?? []),
        lastUsed: metadata?['loadedAt'] as DateTime? ?? DateTime.now(),
        memoryUsage: metadata?['memoryUsage'] as int? ?? 0,
        isEnabled: true,
        metadata: metadata,
      );
    }).toList();
  }

  /// Erhalte Plugin Metadata
  Map<String, dynamic>? getPluginMetadata(String pluginId) {
    return _pluginMetadata[pluginId];
  }

  // =========================================================================
  // SECURITY
  // =========================================================================

  /// Pr√ºfe Sicherheitsstatus
  Future<RaspCheckResult> checkSecurity() async {
    _requireInitialized();

    debugPrint('üõ°Ô∏è Pr√ºfe Security...');

    try {
      final root = await ffi.raspCheckRoot();
      final debugger = await ffi.raspCheckDebugger();
      final emulator = await ffi.raspCheckEmulator();
      final tamper = await ffi.raspCheckTamper();

      final result = RaspCheckResult(
        root: root,
        debugger: debugger,
        emulator: emulator,
        tamper: tamper,
      );

      debugPrint('‚úÖ Security Check: $result');
      return result;
    } catch (e) {
      debugPrint('‚ùå Security Check fehlgeschlagen: $e');
      rethrow;
    }
  }

  /// Ist das Ger√§t root/jailbroken?
  Future<bool> isRooted() async {
    final result = await ffi.raspCheckRoot();
    return result == 2; // 2 = compromised
  }

  /// Wird die App debugged?
  Future<bool> isDebugged() async {
    final result = await ffi.raspCheckDebugger();
    return result == 2; // 2 = compromised
  }

  /// L√§uft die App in einem Emulator?
  Future<bool> isEmulated() async {
    final result = await ffi.raspCheckEmulator();
    return result >= 1; // 1 = suspicious, 2 = compromised
  }

  // =========================================================================
  // PROPERTIES
  // =========================================================================

  bool get isInitialized => _initialized;

  List<String> get loadedPlugins => List.from(_loadedPlugins);

  int get pluginCount => _loadedPlugins.length;

  // =========================================================================
  // ENHANCED SERVICE INTEGRATION
  // =========================================================================

  /// Lade ein Plugin mit erweiterten Services
  ///
  /// Unterst√ºtzt:
  /// - Storage Service Integration
  /// - Network Service Integration
  /// - Permission Service Integration
  /// - Monitoring Service Integration
  Future<String> loadPluginWithServices(
    String pluginPath, {
    required List<String> permissions,
    Map<String, dynamic>? config,
  }) async {
    if (!_initialized) {
      throw ConnectiasException('Service nicht initialisiert');
    }

    debugPrint('üì¶ Lade Plugin mit Services: $pluginPath');
    debugPrint('üîê Berechtigungen: $permissions');
    debugPrint('‚öôÔ∏è Konfiguration: $config');

    try {
      // 1. Permission Service: Berechtigungen pr√ºfen
      await _validatePermissions(permissions);

      // 2. Plugin laden
      final pluginId = await _loadPluginInternal(pluginPath);

      // 3. Services initialisieren
      await _initializePluginServices(pluginId, permissions, config);

      // 4. Monitoring starten
      await _startPluginMonitoring(pluginId);

      _loadedPlugins.add(pluginId);
      notifyListeners();

      debugPrint('‚úÖ Plugin mit Services geladen: $pluginId');
      return pluginId;
    } catch (e) {
      debugPrint('‚ùå Plugin-Loading mit Services fehlgeschlagen: $e');
      throw ConnectiasException('Plugin-Loading fehlgeschlagen: $e');
    }
  }

  /// F√ºhre Plugin mit Service-Integration aus
  Future<Map<String, dynamic>> executePluginWithServices(
    String pluginId,
    String command,
    Map<String, dynamic> args, {
    bool useStorage = false,
    bool useNetwork = false,
    bool trackPerformance = true,
  }) async {
    if (!_initialized) {
      throw ConnectiasException('Service nicht initialisiert');
    }

    if (!_loadedPlugins.contains(pluginId)) {
      throw ConnectiasException('Plugin nicht geladen: $pluginId');
    }

    debugPrint('‚öôÔ∏è F√ºhre Plugin mit Services aus: $pluginId');
    debugPrint('üìã Command: $command');
    debugPrint('üîß Args: $args');

    try {
      final startTime = DateTime.now();

      // 1. Pre-Execution: Services vorbereiten
      if (useStorage) {
        await _prepareStorageService(pluginId);
      }
      if (useNetwork) {
        await _prepareNetworkService(pluginId);
      }

      // 2. Plugin ausf√ºhren
      final result = await _executePluginInternal(pluginId, command, args);

      // 3. Post-Execution: Services aufr√§umen
      if (useStorage) {
        await _cleanupStorageService(pluginId);
      }
      if (useNetwork) {
        await _cleanupNetworkService(pluginId);
      }

      // 4. Performance-Tracking
      if (trackPerformance) {
        final executionTime = DateTime.now().difference(startTime);
        await _recordPerformanceMetrics(pluginId, command, executionTime);
      }

      debugPrint('‚úÖ Plugin mit Services ausgef√ºhrt: $pluginId');
      return {'result': result};
    } catch (e) {
      debugPrint('‚ùå Plugin-Ausf√ºhrung mit Services fehlgeschlagen: $e');
      throw ConnectiasException('Plugin-Ausf√ºhrung fehlgeschlagen: $e');
    }
  }

  /// Hole Threat Events f√ºr Security Dashboard
  Future<List<ThreatEvent>> getThreatEvents() async {
    if (!_initialized) {
      throw ConnectiasException('Service nicht initialisiert');
    }

    debugPrint('üîç Hole Threat Events...');

    try {
      // Simuliere Threat Events f√ºr Demo
      final events = <ThreatEvent>[
        ThreatEvent(
          pluginId: 'demo-plugin-1',
          description: 'Suspicious network activity detected',
          severity: 'medium',
          timestamp: DateTime.now()
              .subtract(const Duration(minutes: 5))
              .toIso8601String(),
          indicators: ['network_anomaly', 'high_frequency'],
        ),
        ThreatEvent(
          pluginId: 'demo-plugin-2',
          description: 'Resource abuse detected',
          severity: 'high',
          timestamp: DateTime.now()
              .subtract(const Duration(minutes: 15))
              .toIso8601String(),
          indicators: ['cpu_abuse', 'memory_leak'],
        ),
      ];

      debugPrint('‚úÖ Threat Events abgerufen: ${events.length}');
      return events;
    } catch (e) {
      debugPrint('‚ùå Threat Events-Abruf fehlgeschlagen: $e');
      throw ConnectiasException('Threat Events-Abruf fehlgeschlagen: $e');
    }
  }

  /// Hole Plugin Security Info f√ºr Security Dashboard
  Future<List<PluginSecurityInfo>> getPluginSecurityInfo() async {
    if (!_initialized) {
      throw ConnectiasException('Service nicht initialisiert');
    }

    debugPrint('üîê Hole Plugin Security Info...');

    try {
      // Simuliere Plugin Security Info f√ºr Demo
      final securityInfo = <PluginSecurityInfo>[
        PluginSecurityInfo(
          pluginId: 'demo-plugin-1',
          isSecure: true,
          permissions: ['storage:read', 'network:https'],
          threatCount: 0,
          securityScore: 0.95,
        ),
        PluginSecurityInfo(
          pluginId: 'demo-plugin-2',
          isSecure: false,
          permissions: ['storage:write', 'network:http', 'system:admin'],
          threatCount: 3,
          securityScore: 0.45,
        ),
      ];

      debugPrint('‚úÖ Plugin Security Info abgerufen: ${securityInfo.length}');
      return securityInfo;
    } catch (e) {
      debugPrint('‚ùå Plugin Security Info-Abruf fehlgeschlagen: $e');
      throw ConnectiasException(
        'Plugin Security Info-Abruf fehlgeschlagen: $e',
      );
    }
  }

  /// Hole Security Metrics f√ºr Security Dashboard
  Future<SecurityMetrics> getSecurityMetrics() async {
    if (!_initialized) {
      throw ConnectiasException('Service nicht initialisiert');
    }

    debugPrint('üìä Hole Security Metrics...');

    try {
      // Simuliere Security Metrics f√ºr Demo
      final metrics = SecurityMetrics(
        threatsBlocked: 42,
        pluginsMonitored: _loadedPlugins.length,
        rateLimitsHit: 8,
        securityScore: 0.87,
        lastUpdate: DateTime.now(),
      );

      debugPrint('‚úÖ Security Metrics abgerufen');
      return metrics;
    } catch (e) {
      debugPrint('‚ùå Security Metrics-Abruf fehlgeschlagen: $e');
      throw ConnectiasException('Security Metrics-Abruf fehlgeschlagen: $e');
    }
  }

  /// Hole Plugin-Statistiken mit Service-Details
  Future<Map<String, dynamic>> getPluginStatsWithServices(
    String pluginId,
  ) async {
    if (!_initialized) {
      throw ConnectiasException('Service nicht initialisiert');
    }

    if (!_loadedPlugins.contains(pluginId)) {
      throw ConnectiasException('Plugin nicht geladen: $pluginId');
    }

    debugPrint('üìä Hole Plugin-Statistiken mit Services: $pluginId');

    try {
      final stats = <String, dynamic>{};

      // 1. Basis-Plugin-Info
      stats['pluginId'] = pluginId;
      stats['loadedAt'] = _pluginMetadata[pluginId]?['loadedAt'];

      // 2. Performance-Metriken
      final performanceMetrics = await _getPerformanceMetrics(pluginId);
      stats['performance'] = performanceMetrics;

      // 3. Storage-Statistiken
      final storageStats = await _getStorageStats(pluginId);
      stats['storage'] = storageStats;

      // 4. Network-Statistiken
      final networkStats = await _getNetworkStats(pluginId);
      stats['network'] = networkStats;

      // 5. Permission-Status
      final permissionStatus = await _getPermissionStatus(pluginId);
      stats['permissions'] = permissionStatus;

      debugPrint('‚úÖ Plugin-Statistiken mit Services abgerufen: $pluginId');
      return stats;
    } catch (e) {
      debugPrint('‚ùå Plugin-Statistiken-Abruf fehlgeschlagen: $e');
      throw ConnectiasException('Plugin-Statistiken-Abruf fehlgeschlagen: $e');
    }
  }

  // =========================================================================
  // SERVICE INTEGRATION HELPERS
  // =========================================================================

  /// Validiere Plugin-Berechtigungen
  Future<void> _validatePermissions(List<String> permissions) async {
    debugPrint('üîê Validiere Berechtigungen: $permissions');

    // Hier w√ºrde die echte Permission-Validierung stattfinden
    // F√ºr jetzt simulieren wir die Validierung
    for (final permission in permissions) {
      if (permission.startsWith('system:')) {
        throw ConnectiasException(
          'System-Berechtigungen nicht erlaubt: $permission',
        );
      }
    }

    debugPrint('‚úÖ Berechtigungen validiert');
  }

  /// Initialisiere Plugin-Services
  Future<void> _initializePluginServices(
    String pluginId,
    List<String> permissions,
    Map<String, dynamic>? config,
  ) async {
    debugPrint('üîß Initialisiere Services f√ºr Plugin: $pluginId');

    // 1. Storage Service initialisieren
    if (permissions.contains('storage:read') ||
        permissions.contains('storage:write')) {
      await _initializeStorageService(pluginId, config);
    }

    // 2. Network Service initialisieren
    if (permissions.contains('network:https') ||
        permissions.contains('network:http')) {
      await _initializeNetworkService(pluginId, config);
    }

    // 3. Monitoring Service initialisieren
    await _initializeMonitoringService(pluginId);

    debugPrint('‚úÖ Services f√ºr Plugin initialisiert: $pluginId');
  }

  /// Starte Plugin-Monitoring
  Future<void> _startPluginMonitoring(String pluginId) async {
    debugPrint('üìä Starte Monitoring f√ºr Plugin: $pluginId');

    // Hier w√ºrde das echte Monitoring gestartet werden
    // F√ºr jetzt simulieren wir das Monitoring
    _pluginMetadata[pluginId] = {
      'loadedAt': DateTime.now().toIso8601String(),
      'monitoringActive': true,
    };

    debugPrint('‚úÖ Monitoring f√ºr Plugin gestartet: $pluginId');
  }

  /// Bereite Storage Service vor
  Future<void> _prepareStorageService(String pluginId) async {
    debugPrint('üíæ Bereite Storage Service vor: $pluginId');

    // Hier w√ºrde der Storage Service vorbereitet werden
    // F√ºr jetzt simulieren wir die Vorbereitung
    await Future.delayed(const Duration(milliseconds: 10));

    debugPrint('‚úÖ Storage Service vorbereitet: $pluginId');
  }

  /// Bereite Network Service vor
  Future<void> _prepareNetworkService(String pluginId) async {
    debugPrint('üåê Bereite Network Service vor: $pluginId');

    // Hier w√ºrde der Network Service vorbereitet werden
    // F√ºr jetzt simulieren wir die Vorbereitung
    await Future.delayed(const Duration(milliseconds: 10));

    debugPrint('‚úÖ Network Service vorbereitet: $pluginId');
  }

  /// R√§ume Storage Service auf
  Future<void> _cleanupStorageService(String pluginId) async {
    debugPrint('üßπ R√§ume Storage Service auf: $pluginId');

    // Hier w√ºrde der Storage Service aufger√§umt werden
    // F√ºr jetzt simulieren wir das Cleanup
    await Future.delayed(const Duration(milliseconds: 5));

    debugPrint('‚úÖ Storage Service aufger√§umt: $pluginId');
  }

  /// R√§ume Network Service auf
  Future<void> _cleanupNetworkService(String pluginId) async {
    debugPrint('üßπ R√§ume Network Service auf: $pluginId');

    // Hier w√ºrde der Network Service aufger√§umt werden
    // F√ºr jetzt simulieren wir das Cleanup
    await Future.delayed(const Duration(milliseconds: 5));

    debugPrint('‚úÖ Network Service aufger√§umt: $pluginId');
  }

  /// Zeichne Performance-Metriken auf
  Future<void> _recordPerformanceMetrics(
    String pluginId,
    String command,
    Duration executionTime,
  ) async {
    debugPrint('üìà Zeichne Performance-Metriken auf: $pluginId');

    // Hier w√ºrden die echten Performance-Metriken aufgezeichnet werden
    // F√ºr jetzt simulieren wir das Recording
    final metrics =
        _pluginMetadata[pluginId]?['metrics'] ?? <String, dynamic>{};
    metrics[command] = {
      'executionTime': executionTime.inMilliseconds,
      'timestamp': DateTime.now().toIso8601String(),
    };

    if (_pluginMetadata[pluginId] != null) {
      _pluginMetadata[pluginId]!['metrics'] = metrics;
    }

    debugPrint('‚úÖ Performance-Metriken aufgezeichnet: $pluginId');
  }

  /// Hole Performance-Metriken
  Future<Map<String, dynamic>> _getPerformanceMetrics(String pluginId) async {
    debugPrint('üìä Hole Performance-Metriken: $pluginId');

    // Hier w√ºrden die echten Performance-Metriken abgerufen werden
    // F√ºr jetzt simulieren wir die Metriken
    final metrics =
        _pluginMetadata[pluginId]?['metrics'] ?? <String, dynamic>{};

    return {
      'totalExecutions': metrics.length,
      'averageExecutionTime': 100, // Simulierte Durchschnittszeit
      'lastExecution': metrics.isNotEmpty ? metrics.values.last : null,
    };
  }

  /// Hole Storage-Statistiken
  Future<Map<String, dynamic>> _getStorageStats(String pluginId) async {
    debugPrint('üíæ Hole Storage-Statistiken: $pluginId');

    // Hier w√ºrden die echten Storage-Statistiken abgerufen werden
    // F√ºr jetzt simulieren wir die Statistiken
    return {
      'usedSpace': 1024 * 1024, // 1MB
      'maxSpace': 10 * 1024 * 1024, // 10MB
      'filesCount': 5,
      'lastAccess': DateTime.now().toIso8601String(),
    };
  }

  /// Hole Network-Statistiken
  Future<Map<String, dynamic>> _getNetworkStats(String pluginId) async {
    debugPrint('üåê Hole Network-Statistiken: $pluginId');

    // Hier w√ºrden die echten Network-Statistiken abgerufen werden
    // F√ºr jetzt simulieren wir die Statistiken
    return {
      'requestsCount': 10,
      'bytesTransferred': 50 * 1024, // 50KB
      'averageResponseTime': 200, // 200ms
      'lastRequest': DateTime.now().toIso8601String(),
    };
  }

  /// Hole Permission-Status
  Future<Map<String, dynamic>> _getPermissionStatus(String pluginId) async {
    debugPrint('üîê Hole Permission-Status: $pluginId');

    // Hier w√ºrde der echte Permission-Status abgerufen werden
    // F√ºr jetzt simulieren wir den Status
    return {
      'granted': ['storage:read', 'storage:write', 'network:https'],
      'denied': [],
      'requested': ['storage:read', 'storage:write', 'network:https'],
    };
  }

  /// Initialisiere Storage Service
  Future<void> _initializeStorageService(
    String pluginId,
    Map<String, dynamic>? config,
  ) async {
    debugPrint('üíæ Initialisiere Storage Service: $pluginId');

    // Hier w√ºrde der echte Storage Service initialisiert werden
    // F√ºr jetzt simulieren wir die Initialisierung
    await Future.delayed(const Duration(milliseconds: 20));

    debugPrint('‚úÖ Storage Service initialisiert: $pluginId');
  }

  /// Initialisiere Network Service
  Future<void> _initializeNetworkService(
    String pluginId,
    Map<String, dynamic>? config,
  ) async {
    debugPrint('üåê Initialisiere Network Service: $pluginId');

    // Hier w√ºrde der echte Network Service initialisiert werden
    // F√ºr jetzt simulieren wir die Initialisierung
    await Future.delayed(const Duration(milliseconds: 20));

    debugPrint('‚úÖ Network Service initialisiert: $pluginId');
  }

  /// Initialisiere Monitoring Service
  Future<void> _initializeMonitoringService(String pluginId) async {
    debugPrint('üìä Initialisiere Monitoring Service: $pluginId');

    // Hier w√ºrde der echte Monitoring Service initialisiert werden
    // F√ºr jetzt simulieren wir die Initialisierung
    await Future.delayed(const Duration(milliseconds: 10));

    debugPrint('‚úÖ Monitoring Service initialisiert: $pluginId');
  }

  /// Interne Plugin-Loading-Methode
  Future<String> _loadPluginInternal(String pluginPath) async {
    return await ffi.loadPlugin(pluginPath);
  }

  /// Interne Plugin-Ausf√ºhrungs-Methode
  Future<String> _executePluginInternal(
    String pluginId,
    String command,
    Map<String, dynamic> args,
  ) async {
    // Konvertiere Map<String, dynamic> zu Map<String, String>
    final stringArgs = args.map(
      (key, value) => MapEntry(key, value.toString()),
    );
    return await ffi.executePlugin(pluginId, command, stringArgs);
  }
}

// ============================================================================
// MODELS & EXCEPTIONS
// ============================================================================

/// Ergebnis eines RASP-Checks
class RaspCheckResult {
  final int root;
  final int debugger;
  final int emulator;
  final int tamper;

  RaspCheckResult({
    required this.root,
    required this.debugger,
    required this.emulator,
    required this.tamper,
  });

  bool get isSafe => root == 0 && debugger == 0 && emulator == 0 && tamper == 0;

  bool get isCompromised => root == 2 || debugger == 2;

  bool get isSuspicious => !isSafe && !isCompromised;

  @override
  String toString() =>
      'RaspCheckResult(root: $root, debugger: $debugger, emulator: $emulator, tamper: $tamper)';
}

/// Exception f√ºr Connectias Fehler
class ConnectiasException implements Exception {
  final String message;
  final Object? originalError;

  ConnectiasException(this.message, [this.originalError]);

  @override
  String toString() =>
      'ConnectiasException: $message${originalError != null ? '\nCause: $originalError' : ''}';
}

/// Exception f√ºr Security Violations
class ConnectiasSecurityException implements Exception {
  final String message;
  final ffi.RaspStatus? raspStatus;

  ConnectiasSecurityException(this.message, [this.raspStatus]);

  @override
  String toString() =>
      'ConnectiasSecurityException: $message${raspStatus != null ? '\nStatus: $raspStatus' : ''}';
}

// Data Models f√ºr erweiterte Security-Features
class ThreatEvent {
  final String pluginId;
  final String description;
  final String severity;
  final String timestamp;
  final List<String> indicators;

  ThreatEvent({
    required this.pluginId,
    required this.description,
    required this.severity,
    required this.timestamp,
    required this.indicators,
  });
}

class PluginSecurityInfo {
  final String pluginId;
  final bool isSecure;
  final List<String> permissions;
  final int threatCount;
  final double securityScore;

  PluginSecurityInfo({
    required this.pluginId,
    required this.isSecure,
    required this.permissions,
    required this.threatCount,
    required this.securityScore,
  });
}

class SecurityMetrics {
  final int threatsBlocked;
  final int pluginsMonitored;
  final int rateLimitsHit;
  final double securityScore;
  final DateTime lastUpdate;

  SecurityMetrics({
    required this.threatsBlocked,
    required this.pluginsMonitored,
    required this.rateLimitsHit,
    required this.securityScore,
    required this.lastUpdate,
  });
}

/// Globale ConnectiasService Instance
final connectiasService = ConnectiasService();

/// Convenience Function f√ºr Plugin-Laden
Future<String> loadConnectiasPlugin(String pluginPath) async {
  return connectiasService.loadPlugin(pluginPath);
}
