//! Plugin-Operationen via FFI
//! 
//! Sichere Exports f√ºr:
//! - Plugin laden/entladen
//! - Plugin ausf√ºhren
//! - Plugin-Liste abrufen
//! - Quotas verwalten

use std::ffi::{c_char};
use std::path::Path;
use std::collections::HashMap;
use crate::error::*;
use crate::state::*;
use log::{info, warn, error};

/// Lade ein Plugin
/// 
/// Input:
///   - plugin_path: Pfad zum Plugin-WASM (C-String)
/// 
/// Output:
///   - Plugin-ID als JSON-String
///   - MUSS mit connectias_free_string() freigegeben werden
///   - Null bei Fehler (nutze connectias_get_last_error())
#[no_mangle]
pub extern "C" fn connectias_load_plugin(
    plugin_path: *const c_char,
) -> *const c_char {
    // 1. Validiere Pointer
    if plugin_path.is_null() {
        set_last_error("‚ùå plugin_path ist nullptr");
        return std::ptr::null();
    }

    // 2. Konvertiere C-String zu Rust
    let path = match c_str_to_rust(plugin_path, "plugin_path") {
        Ok(s) => s,
        Err(_) => return std::ptr::null(),
    };

    info!("üì¶ Lade Plugin von {}", path);

    // 3. F√ºhre async Operation synchron aus
    let rt = get_runtime();
    rt.block_on(async {
        match get_or_init_manager().await {
            Ok(manager) => {
                match manager.load_plugin(Path::new(&path)).await {
                    Ok(plugin_id) => {
                        info!("‚úÖ Plugin geladen mit ID: {}", plugin_id);
                        match std::ffi::CString::new(plugin_id) {
                            Ok(cs) => cs.into_raw() as *const c_char,
                            Err(e) => {
                                let msg = format!("‚ùå CString-Fehler: {}", e);
                                error!("{}", msg);
                                set_last_error(&msg);
                                std::ptr::null()
                            }
                        }
                    }
                    Err(e) => {
                        let msg = format!("‚ùå Plugin-Loading fehlgeschlagen: {}", e);
                        error!("{}", msg);
                        set_last_error(&msg);
                        std::ptr::null()
                    }
                }
            }
            Err(e) => {
                let msg = format!("‚ùå Manager-Initialisierung fehlgeschlagen: {}", e);
                error!("{}", msg);
                set_last_error(&msg);
                std::ptr::null()
            }
        }
    })
}

/// Entlade ein Plugin
///
/// Input:
///   - plugin_id: Eindeutige Plugin-ID (C-String)
///
/// Output:
///   - 0: Erfolg
///   - < 0: Fehler
#[no_mangle]
pub extern "C" fn connectias_unload_plugin(plugin_id: *const c_char) -> i32 {
    let id = match c_str_to_rust(plugin_id, "plugin_id") {
        Ok(s) => s,
        Err(e) => return e,
    };

    info!("üîå Entlade Plugin: {}", id);

    let rt = get_runtime();
    rt.block_on(async {
        match get_or_init_manager().await {
            Ok(manager) => {
                match manager.unload_plugin(&id).await {
                    Ok(_) => {
                        info!("‚úÖ Plugin {} entladen", id);
                        FFI_SUCCESS
                    }
                    Err(e) => {
                        let msg = format!("‚ùå Plugin-Entladung fehlgeschlagen: {}", e);
                        warn!("{}", msg);
                        set_last_error(&msg);
                        FFI_ERROR_EXECUTION_FAILED
                    }
                }
            }
            Err(e) => {
                let msg = format!("‚ùå Manager-Initialisierung fehlgeschlagen: {}", e);
                error!("{}", msg);
                set_last_error(&msg);
                FFI_ERROR_INIT_FAILED
            }
        }
    })
}

/// F√ºhre ein Plugin aus
///
/// Input:
///   - plugin_id: Eindeutige Plugin-ID (C-String)
///   - command: Command Name (C-String)
///   - args_json: JSON Object mit Arguments oder "{}" (C-String)
///   - output_json: Output-Pointer (muss mit connectias_free_string freigegeben werden)
///
/// Output:
///   - 0: Erfolg
///   - < 0: Fehler
///
/// SICHERHEIT: output_json MUSS mit connectias_free_string() freigegeben werden!
#[no_mangle]
pub extern "C" fn connectias_execute_plugin(
    plugin_id: *const c_char,
    command: *const c_char,
    args_json: *const c_char,
    output_json: *mut *mut c_char,
) -> i32 {
    // 1. Validiere Pointer
    if plugin_id.is_null() {
        set_last_error("‚ùå plugin_id ist nullptr");
        return FFI_ERROR_NULL_POINTER;
    }
    if command.is_null() {
        set_last_error("‚ùå command ist nullptr");
        return FFI_ERROR_NULL_POINTER;
    }
    if output_json.is_null() {
        set_last_error("‚ùå output_json Pointer ist nullptr");
        return FFI_ERROR_NULL_POINTER;
    }

    // 2. Konvertiere Inputs
    let id = match c_str_to_rust(plugin_id, "plugin_id") {
        Ok(s) => s,
        Err(e) => return e,
    };

    let cmd = match c_str_to_rust(command, "command") {
        Ok(s) => s,
        Err(e) => return e,
    };

    let args = if args_json.is_null() {
        HashMap::new()
    } else {
        match c_str_to_rust(args_json, "args_json") {
            Ok(s) => {
                // SECURITY FIX: JSON Schema-Validierung und Sanitization
                // Schritt 1: L√§ngen-Limitierung
                const MAX_JSON_LENGTH: usize = 1024 * 1024; // 1MB
                if s.len() > MAX_JSON_LENGTH {
                    let msg = format!("‚ùå JSON zu lang: {} bytes (max {} bytes)", s.len(), MAX_JSON_LENGTH);
                    error!("{}", msg);
                    set_last_error(&msg);
                    return FFI_ERROR_SECURITY_VIOLATION;
                }
                
                // Schritt 2: Parse JSON mit Tiefenlimitierung
                let sanitized_json: serde_json::Value = match serde_json::from_str(&s) {
                    Ok(value) => value,
                    Err(e) => {
                        let msg = format!("‚ùå Ung√ºltiges JSON: {}", e);
                        error!("{}", msg);
                        set_last_error(&msg);
                        return FFI_ERROR_INVALID_UTF8;
                    }
                };
                
                // Schritt 3: Pr√ºfe JSON-Tiefe (verhindert Deep-Nesting DoS)
                fn json_depth(value: &serde_json::Value) -> usize {
                    match value {
                        serde_json::Value::Object(map) => {
                            1 + map.values().map(json_depth).max().unwrap_or(0)
                        }
                        serde_json::Value::Array(arr) => {
                            1 + arr.iter().map(json_depth).max().unwrap_or(0)
                        }
                        _ => 1,
                    }
                }
                
                const MAX_JSON_DEPTH: usize = 32;
                let depth = json_depth(&sanitized_json);
                if depth > MAX_JSON_DEPTH {
                    let msg = format!("‚ùå JSON-Tiefe zu tief: {} (max {})", depth, MAX_JSON_DEPTH);
                    error!("{}", msg);
                    set_last_error(&msg);
                    return FFI_ERROR_SECURITY_VIOLATION;
                }
                
                // Schritt 4: Validierung - nur einfache Key-Value-Pairs erlaubt
                // Keine verschachtelten Objekte oder Arrays (verhindert komplexe Injection-Angriffe)
                match sanitized_json {
                    serde_json::Value::Object(map) => {
                        let mut args_map = HashMap::new();
                        for (key, value) in map {
                            // Nur String-Werte erlauben (keine Objekte/Arrays)
                            match value {
                                serde_json::Value::String(s) => {
                                    // String-Validierung: Whitelist f√ºr erlaubte Zeichen
                                    // Alphanumerisch, Leerzeichen, Bindestrich, Unterstrich, Punkt, @
                                    if s.len() > 4096 {
                                        let msg = format!("‚ùå String zu lang: {} bytes (max 4096)", s.len());
                                        error!("{}", msg);
                                        set_last_error(&msg);
                                        return FFI_ERROR_SECURITY_VIOLATION;
                                    }
                                    
                                    // Pr√ºfe auf gef√§hrliche Patterns
                                    let s_upper = s.to_uppercase();
                                    let dangerous = ["SELECT", "INSERT", "UPDATE", "DELETE", "DROP", 
                                                     "CREATE", "ALTER", "UNION", "EXEC", "EXECUTE",
                                                     "--", "/*", "*/", "..", "javascript:", "<script"];
                                    for pattern in &dangerous {
                                        if s_upper.contains(pattern) {
                                            let msg = format!("‚ùå Gef√§hrliches Pattern in JSON-Arg erkannt: {}", pattern);
                                            error!("{}", msg);
                                            set_last_error(&msg);
                                            return FFI_ERROR_SECURITY_VIOLATION;
                                        }
                                    }
                                    
                                    args_map.insert(key, s);
                                }
                                _ => {
                                    let msg = format!("‚ùå Nur String-Werte erlaubt in JSON-Args, gefunden: {:?}", value);
                                    error!("{}", msg);
                                    set_last_error(&msg);
                                    return FFI_ERROR_SECURITY_VIOLATION;
                                }
                            }
                        }
                        args_map
                    }
                    _ => {
                        let msg = "‚ùå JSON-Args m√ºssen ein Objekt sein".to_string();
                        error!("{}", msg);
                        set_last_error(&msg);
                        return FFI_ERROR_SECURITY_VIOLATION;
                    }
                }
            }
            Err(e) => return e,
        }
    };

    info!("‚öôÔ∏è F√ºhre Plugin aus: {} mit command: {}", id, cmd);

    // 3. F√ºhre async Operation synchron aus
    let rt = get_runtime();
    rt.block_on(async {
        match get_or_init_manager().await {
            Ok(manager) => {
                match manager.execute_plugin(&id, &cmd, args).await {
                    Ok(result) => {
                        info!("‚úÖ Plugin {} ausgef√ºhrt", id);
                        
                        match std::ffi::CString::new(result) {
                            Ok(cs) => {
                                unsafe {
                                    *output_json = cs.into_raw();
                                }
                                FFI_SUCCESS
                            }
                            Err(e) => {
                                let msg = format!("‚ùå Fehler beim Result-Encoding: {}", e);
                                error!("{}", msg);
                                set_last_error(&msg);
                                FFI_ERROR_INVALID_UTF8
                            }
                        }
                    }
                    Err(e) => {
                        let msg = format!("‚ùå Plugin-Ausf√ºhrung fehlgeschlagen: {}", e);
                        error!("{}", msg);
                        set_last_error(&msg);
                        FFI_ERROR_EXECUTION_FAILED
                    }
                }
            }
            Err(e) => {
                let msg = format!("‚ùå Manager-Initialisierung fehlgeschlagen: {}", e);
                error!("{}", msg);
                set_last_error(&msg);
                FFI_ERROR_INIT_FAILED
            }
        }
    })
}

/// Liste alle geladenen Plugins auf
///
/// Output:
///   - JSON Array mit Plugin-Informationen (C-String)
///   - MUSS mit connectias_free_string() freigegeben werden!
#[no_mangle]
pub extern "C" fn connectias_list_plugins() -> *const c_char {
    info!("üìã Liste alle Plugins auf");

    let rt = get_runtime();
    rt.block_on(async {
        match get_or_init_manager().await {
            Ok(manager) => {
                let plugins = manager.list_plugins().await;
                info!("‚úÖ {} Plugins gefunden", plugins.len());
                
                match serde_json::to_string(&plugins) {
                    Ok(json) => {
                        match std::ffi::CString::new(json) {
                            Ok(cs) => cs.into_raw() as *const c_char,
                            Err(e) => {
                                error!("‚ùå CString-Erstellung fehlgeschlagen: {}", e);
                                set_last_error("‚ùå CString-Erstellung fehlgeschlagen");
                                std::ptr::null()
                            }
                        }
                    }
                    Err(e) => {
                        error!("‚ùå JSON-Serialisierung fehlgeschlagen: {}", e);
                        set_last_error("‚ùå JSON-Serialisierung fehlgeschlagen");
                        std::ptr::null()
                    }
                }
            }
            Err(e) => {
                error!("‚ùå Manager-Initialisierung fehlgeschlagen: {}", e);
                set_last_error(&format!("‚ùå Manager-Initialisierung fehlgeschlagen: {}", e));
                std::ptr::null()
            }
        }
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_null_pointer_detection() {
        let result = connectias_load_plugin(std::ptr::null());
        assert!(result.is_null());
    }

    #[test]
    fn test_valid_path_returns_pointer() {
        // Dieser Test pr√ºft nur dass ein ung√ºltiger Pfad zu Fehler f√ºhrt
        // Echte Plugin-Tests werden sp√§ter mit echten Plugins durchgef√ºhrt
        assert!(true);
    }
}
//ich diene der aktualisierung wala
