name: Android Release

on:
  push:
    branches: [main]

jobs:
  build:
    if: startsWith(github.event.head_commit.message, 'releasebuild')
    environment: Keystore release build
    permissions:
      contents: write
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for version calculation

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 21
          cache: gradle  # P2: Enable dependency caching

      - name: Set up Gradle
        uses: gradle/actions/setup-gradle@v4
        with:
          gradle-version: 9.2.1
          cache-read-only: false  # P2: Explicit cache configuration

      - name: Make gradlew executable
        run: chmod +x gradlew

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-linux-android,armv7-linux-androideabi,x86_64-linux-android,i686-linux-android

      - name: Set up Android NDK
        uses: nttld/setup-ndk@v1
        with:
          ndk-version: r26

      - name: Install cargo-ndk
        run: cargo install cargo-ndk

      - name: Build Rust libraries
        working-directory: core/src/main/rust
        run: |
          echo "Building Rust libraries for all Android ABIs..."
          
          # Build for all Android ABIs
          # Rust target names -> Android ABI names mapping
          declare -A ABI_MAP=(
            ["aarch64-linux-android"]="arm64-v8a"
            ["armv7-linux-androideabi"]="armeabi-v7a"
            ["x86_64-linux-android"]="x86_64"
            ["i686-linux-android"]="x86"
          )
          
          RUST_ABIS=("aarch64-linux-android" "armv7-linux-androideabi" "x86_64-linux-android" "i686-linux-android")
          
          # Use absolute path for jniLibs directory (relative to repository root)
          # From core/src/main/rust, we need to go up 3 levels to reach root
          WORKSPACE="${GITHUB_WORKSPACE:-$(cd ../.. && pwd)}"
          JNI_LIBS_BASE="${WORKSPACE}/core/src/main/jniLibs"
          
          echo "Workspace: ${WORKSPACE}"
          echo "jniLibs directory: ${JNI_LIBS_BASE}"
          
          # Create jniLibs directory structure upfront
          mkdir -p "${JNI_LIBS_BASE}"
          
          for RUST_ABI in "${RUST_ABIS[@]}"; do
            echo "Building for ${RUST_ABI}..."
            cargo ndk \
              --target "${RUST_ABI}" \
              --platform 33 \
              -- build --release
            
            # Verify build succeeded
            TARGET_DIR="target/${RUST_ABI}/release"
            LIB_FILE="${TARGET_DIR}/libconnectias_root_detector.so"
            
            if [ ! -f "${LIB_FILE}" ]; then
              echo "‚úó Build failed for ${RUST_ABI} - library not found at ${LIB_FILE}"
              exit 1
            fi
            
            echo "‚úì Built successfully for ${RUST_ABI}"
            
            # Get Android ABI name
            ANDROID_ABI="${ABI_MAP[${RUST_ABI}]}"
            
            # Copy to jniLibs directory for Gradle to find (direct inclusion in APK)
            # This is the critical path: core/src/main/jniLibs/${ANDROID_ABI}/libconnectias_root_detector.so
            JNI_LIBS_DIR="${JNI_LIBS_BASE}/${ANDROID_ABI}"
            mkdir -p "${JNI_LIBS_DIR}"
            
            # Use absolute path for source file (relative to current working directory)
            ABS_LIB_FILE="$(pwd)/${LIB_FILE}"
            cp "${ABS_LIB_FILE}" "${JNI_LIBS_DIR}/libconnectias_root_detector.so"
            
            # Verify copy succeeded
            if [ -f "${JNI_LIBS_DIR}/libconnectias_root_detector.so" ]; then
              echo "‚úì Copied to ${JNI_LIBS_DIR}/libconnectias_root_detector.so"
              ls -lh "${JNI_LIBS_DIR}/libconnectias_root_detector.so"
            else
              echo "‚úó Failed to copy library to ${JNI_LIBS_DIR}/"
              echo "Source file: ${ABS_LIB_FILE}"
              echo "Target directory: ${JNI_LIBS_DIR}"
              exit 1
            fi
            
            # Also create copy for CMake (CMake expects Android ABI names in target/)
            # CMake looks in: core/src/main/rust/target/${ANDROID_ABI}/release/
            CMAKE_TARGET_DIR="target/${ANDROID_ABI}/release"
            mkdir -p "${CMAKE_TARGET_DIR}"
            cp "${LIB_FILE}" "${CMAKE_TARGET_DIR}/libconnectias_root_detector.so"
            echo "‚úì Copied to ${CMAKE_TARGET_DIR}/libconnectias_root_detector.so (for CMake)"
          done
          
          echo ""
          echo "‚úì All Rust builds completed successfully"
          echo ""
          echo "Verifying jniLibs directory structure:"
          find "${JNI_LIBS_BASE}" -name "*.so" -type f | sort
          echo ""
          echo "Library sizes:"
          find "${JNI_LIBS_BASE}" -name "*.so" -type f -exec ls -lh {} \;

      - name: Verify Rust libraries before Gradle build
        run: |
          echo "Verifying Rust libraries are in place before Gradle build..."
          echo "Current working directory: $(pwd)"
          
          # Use absolute path from repository root (GITHUB_WORKSPACE is set by GitHub Actions)
          WORKSPACE="${GITHUB_WORKSPACE:-$PWD}"
          JNI_LIBS_DIR="${WORKSPACE}/core/src/main/jniLibs"
          
          echo "Workspace: ${WORKSPACE}"
          echo "Looking for libraries in: ${JNI_LIBS_DIR}"
          
          # Check if directory exists
          if [ ! -d "${JNI_LIBS_DIR}" ]; then
            echo "‚úó ERROR: jniLibs directory does not exist: ${JNI_LIBS_DIR}"
            echo "Checking parent directory:"
            ls -la "${WORKSPACE}/core/src/main/" 2>/dev/null || echo "core/src/main/ does not exist"
            exit 1
          fi
          
          # Check for arm64-v8a (required for release build)
          if [ ! -f "${JNI_LIBS_DIR}/arm64-v8a/libconnectias_root_detector.so" ]; then
            echo "‚úó ERROR: Required library not found: ${JNI_LIBS_DIR}/arm64-v8a/libconnectias_root_detector.so"
            echo "Available files in jniLibs:"
            find "${JNI_LIBS_DIR}" -type f 2>/dev/null || echo "No files found"
            echo ""
            echo "Directory structure:"
            find "${JNI_LIBS_DIR}" -type d 2>/dev/null || echo "Directory does not exist"
            exit 1
          fi
          
          echo "‚úì Verified: ${JNI_LIBS_DIR}/arm64-v8a/libconnectias_root_detector.so exists"
          ls -lh "${JNI_LIBS_DIR}/arm64-v8a/libconnectias_root_detector.so"
          
          # List all available libraries
          echo ""
          echo "All available native libraries:"
          find "${JNI_LIBS_DIR}" -name "*.so" -type f | sort

      - name: Calculate version and APK name
        id: version
        env:
          COMMIT_MSG: ${{ github.event.head_commit.message }}
        run: |
          # Extract repository name (owner/repo-name -> repo-name)
          REPO_NAME=$(echo "${{ github.repository }}" | awk -F'/' '{print $NF}')
          echo "repo_name=${REPO_NAME}" >> "$GITHUB_OUTPUT"
          
          # P1: Extract version from commit message or use semantic versioning
          # Use only first line of commit message to avoid shell interpretation issues with multi-line content
          # Use printf with %s to safely handle special characters
          COMMIT_MSG_FIRST_LINE=$(printf '%s\n' "$COMMIT_MSG" | head -n1)
          
          # Try to extract version from commit message (format: releasebuild v1.2.3)
          if printf '%s\n' "$COMMIT_MSG_FIRST_LINE" | grep -qE 'v?[0-9]+\.[0-9]+\.[0-9]+'; then
            VERSION=$(printf '%s\n' "$COMMIT_MSG_FIRST_LINE" | grep -oE 'v?[0-9]+\.[0-9]+\.[0-9]+' | head -n1 | sed 's/^v//')
            VERSION_CODE=$(echo "$VERSION" | awk -F. '{printf "%d%02d%02d", $1, $2, $3}')
          else
            # Fallback: Use run number for versioning
            VERSION_CODE=${{ github.run_number }}
            VERSION="1.0.${{ github.run_number }}"
          fi
          
          # Generate APK filename: RepoName-v1.2.3.apk
          APK_FILENAME="${REPO_NAME}-v${VERSION}.apk"
          
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "version_code=${VERSION_CODE}" >> "$GITHUB_OUTPUT"
          echo "tag=v${VERSION}" >> "$GITHUB_OUTPUT"
          echo "apk_filename=${APK_FILENAME}" >> "$GITHUB_OUTPUT"
          
          echo "Repository: ${REPO_NAME}"
          echo "Calculated version: ${VERSION} (code: ${VERSION_CODE})"
          echo "APK filename: ${APK_FILENAME}"

      - name: Recreate keystore
        id: keystore
        env:
          KEYSTORE_BASE64: ${{ secrets.KEYSTORE_BASE64 }}
        run: |
          # P0: Validate keystore secret exists
          if [ -z "$KEYSTORE_BASE64" ]; then
            echo "Error: KEYSTORE_BASE64 secret is not set"
            exit 1
          fi
          
          # Create keystore
          echo "$KEYSTORE_BASE64" | base64 -d > app/keystore.jks
          
          # P0: Validate keystore was created successfully
          if [ ! -f "app/keystore.jks" ]; then
            echo "Error: Failed to create keystore file"
            exit 1
          fi
          
          # P0: Validate keystore file is not empty
          if [ ! -s "app/keystore.jks" ]; then
            echo "Error: Keystore file is empty"
            exit 1
          fi
          
          echo "Keystore created successfully"
          echo "keystore_path=app/keystore.jks" >> "$GITHUB_OUTPUT"

      - name: Run lint and unit tests
        continue-on-error: false  # P0: Fail fast on test failures
        run: ./gradlew lint test

      - name: Generate Jacoco coverage report
        continue-on-error: true  # Don't fail release if coverage report generation fails
        run: |
          echo "Generating Jacoco code coverage report..."
          ./gradlew jacocoTestReport || {
            echo "‚ö†Ô∏è Warning: jacocoTestReport failed"
            echo "This may indicate missing test coverage data"
            echo "Continuing with release build..."
          }
      
      - name: Upload Jacoco coverage reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: jacoco-coverage-${{ steps.version.outputs.version }}
          path: |
            **/build/reports/jacoco/
            **/build/jacoco/
          retention-days: 90
      
      - name: Check for dependency vulnerabilities
        continue-on-error: true  # Don't fail release if dependency check fails (but log warnings)
        run: |
          echo "Running CVE scan for dependencies..."
          ./gradlew dependencyCheckAnalyze || {
            echo "‚ö†Ô∏è Warning: dependencyCheckAnalyze failed or plugin not configured"
            echo "This may indicate missing OWASP Dependency Check plugin configuration"
            echo "Continuing with release build..."
          }
      
      - name: Upload dependency check report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: dependency-check-report
          path: |
            **/build/reports/dependency-check-report.*
            **/build/reports/dependency-check/
          retention-days: 30

      - name: Build signed release APK
        id: build
        env:
          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
          KEY_ALIAS: ${{ secrets.KEY_ALIAS }}
          KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}
          VERSION_NAME: ${{ steps.version.outputs.version }}
          VERSION_CODE: ${{ steps.version.outputs.version_code }}
        run: |
          # P0: Validate all required secrets are set
          if [ -z "$KEYSTORE_PASSWORD" ] || [ -z "$KEY_ALIAS" ] || [ -z "$KEY_PASSWORD" ]; then
            echo "Error: One or more signing secrets are not set"
            exit 1
          fi
          
          # Build with version injection
          ./gradlew :app:assembleRelease \
            -Pandroid.injected.signing.store.file=$GITHUB_WORKSPACE/app/keystore.jks \
            -Pandroid.injected.signing.store.password="$KEYSTORE_PASSWORD" \
            -Pandroid.injected.signing.key.alias="$KEY_ALIAS" \
            -Pandroid.injected.signing.key.password="$KEY_PASSWORD" \
            -PversionName="$VERSION_NAME" \
            -PversionCode="$VERSION_CODE"
          
          # P0: Validate APK was created successfully
          ORIGINAL_APK_PATH="app/build/outputs/apk/release/app-arm64-v8a-release.apk"
          if [ ! -f "$ORIGINAL_APK_PATH" ]; then
            echo "Error: APK file was not created at $ORIGINAL_APK_PATH"
            exit 1
          fi
          
          # P2: Validate APK file is not empty
          APK_SIZE=$(stat -f%z "$ORIGINAL_APK_PATH" 2>/dev/null || stat -c%s "$ORIGINAL_APK_PATH" 2>/dev/null)
          if [ "$APK_SIZE" -eq 0 ]; then
            echo "Error: APK file is empty"
            exit 1
          fi
          
          # Rename APK to use repository name
          APK_FILENAME="${{ steps.version.outputs.apk_filename }}"
          APK_PATH="app/build/outputs/apk/release/${APK_FILENAME}"
          mv "$ORIGINAL_APK_PATH" "$APK_PATH"
          
          # Verify rename was successful
          if [ ! -f "$APK_PATH" ]; then
            echo "Error: Failed to rename APK file"
            exit 1
          fi
          
          # P2: Log APK size for monitoring
          APK_SIZE_MB=$((APK_SIZE / 1024 / 1024))
          APK_SIZE_KB=$((APK_SIZE / 1024))
          echo "APK renamed to: ${APK_FILENAME}"
          echo "APK size: ${APK_SIZE_MB} MB (${APK_SIZE_KB} KB, ${APK_SIZE} bytes)"
          echo "apk_size=${APK_SIZE}" >> "$GITHUB_OUTPUT"
          echo "apk_path=${APK_PATH}" >> "$GITHUB_OUTPUT"
          echo "apk_filename=${APK_FILENAME}" >> "$GITHUB_OUTPUT"
          
          # Generate SHA256 checksum file
          SHA256SUM_FILENAME="${APK_FILENAME}.sha256sum"
          SHA256SUM_PATH="app/build/outputs/apk/release/${SHA256SUM_FILENAME}"
          sha256sum "$APK_PATH" > "$SHA256SUM_PATH"
          
          # Verify SHA256 file was created successfully
          if [ ! -f "$SHA256SUM_PATH" ]; then
            echo "Error: Failed to create SHA256 checksum file"
            exit 1
          fi
          
          # Display SHA256 checksum
          SHA256_HASH=$(sha256sum "$APK_PATH" | awk '{print $1}')
          echo "SHA256 checksum: ${SHA256_HASH}"
          echo "SHA256 checksum file: ${SHA256SUM_FILENAME}"
          echo "sha256sum_path=${SHA256SUM_PATH}" >> "$GITHUB_OUTPUT"
          echo "sha256sum_filename=${SHA256SUM_FILENAME}" >> "$GITHUB_OUTPUT"
          echo "sha256_hash=${SHA256_HASH}" >> "$GITHUB_OUTPUT"

      - name: Prepare ProGuard mapping file
        id: proguard
        run: |
          MAPPING_FILE="app/build/outputs/mapping/release/mapping.txt"
          
          if [ -f "$MAPPING_FILE" ]; then
            echo "‚úÖ ProGuard mapping file found"
            
            # Get mapping file size
            MAPPING_SIZE=$(stat -f%z "$MAPPING_FILE" 2>/dev/null || stat -c%s "$MAPPING_FILE" 2>/dev/null)
            MAPPING_SIZE_KB=$((MAPPING_SIZE / 1024))
            
            echo "Mapping file size: ${MAPPING_SIZE_KB} KB (${MAPPING_SIZE} bytes)"
            
            # Create versioned mapping filename
            MAPPING_FILENAME="${{ steps.version.outputs.repo_name }}-v${{ steps.version.outputs.version }}-mapping.txt"
            MAPPING_OUTPUT="app/build/outputs/mapping/release/${MAPPING_FILENAME}"
            
            # Copy mapping file with versioned name
            cp "$MAPPING_FILE" "$MAPPING_OUTPUT"
            
            echo "mapping_path=${MAPPING_FILE}" >> "$GITHUB_OUTPUT"
            echo "mapping_output=${MAPPING_OUTPUT}" >> "$GITHUB_OUTPUT"
            echo "mapping_filename=${MAPPING_FILENAME}" >> "$GITHUB_OUTPUT"
            echo "mapping_exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "‚ö†Ô∏è Warning: ProGuard mapping file not found at $MAPPING_FILE"
            echo "This may indicate that ProGuard/R8 is not generating mapping files"
            echo "mapping_exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Upload ProGuard mapping file
        if: steps.proguard.outputs.mapping_exists == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: proguard-mapping-${{ steps.version.outputs.version }}
          path: |
            ${{ steps.proguard.outputs.mapping_path }}
            ${{ steps.proguard.outputs.mapping_output }}
          retention-days: 365  # Keep mapping files longer for crash analysis

      - name: Validate APK integrity
        id: validate
        run: |
          APK_PATH="${{ steps.build.outputs.apk_path }}"
          
          # P2: Validate APK is a valid ZIP file (APKs are ZIP archives)
          if ! unzip -t "$APK_PATH" > /dev/null 2>&1; then
            echo "Error: APK file is not a valid ZIP archive"
            exit 1
          fi
          
          # P2: Check for required APK components
          if ! unzip -l "$APK_PATH" | grep -q "AndroidManifest.xml"; then
            echo "Error: APK is missing AndroidManifest.xml"
            exit 1
          fi
          
          echo "APK integrity validation passed"

      - name: Upload release artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.version.outputs.repo_name }}-${{ steps.version.outputs.version }}
          path: |
            ${{ steps.build.outputs.apk_path }}
            ${{ steps.build.outputs.sha256sum_path }}
          retention-days: 90

      - name: Prepare release metadata
        id: relmeta
        env:
          COMMIT_MSG: ${{ github.event.head_commit.message }}
        run: |
          # P1: Extract release name from commit message (first line, remove 'releasebuild' prefix)
          # Use printf with %s to safely handle special characters
          RELEASE_NAME=$(printf '%s\n' "$COMMIT_MSG" | sed -n '1p' | sed 's/^releasebuild[[:space:]]*//i' | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
          
          # Fallback to version if no name provided
          if [ -z "$RELEASE_NAME" ] || [ "$RELEASE_NAME" = "" ]; then
            RELEASE_NAME="Release ${{ steps.version.outputs.version }}"
          fi
          
          # Extract release notes (everything after first line)
          # Use printf to safely handle multi-line content
          RELEASE_NOTES=$(printf '%s\n' "$COMMIT_MSG" | sed -n '2,$p' | sed '/^$/d')
          
          echo "release_name=${RELEASE_NAME}" >> "$GITHUB_OUTPUT"
          echo "release_notes<<EOF" >> "$GITHUB_OUTPUT"
          printf '%s\n' "${RELEASE_NOTES}" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          
          echo "Release name: ${RELEASE_NAME}"
          echo "Release tag: ${{ steps.version.outputs.tag }}"

      - name: Extract coverage summary
        id: coverage
        if: always()
        run: |
          COVERAGE_XML="app/build/reports/jacoco/jacocoTestReport/jacocoTestReport.xml"
          
          if [ -f "$COVERAGE_XML" ]; then
            echo "‚úÖ Coverage report found"
            
            # Extract coverage percentages from XML (if available)
            # This is a simple extraction - can be improved with proper XML parsing
            if command -v xmllint > /dev/null 2>&1; then
              LINE_COVERAGE=$(xmllint --xpath "string(//report/counter[@type='LINE']/@missed)" "$COVERAGE_XML" 2>/dev/null || echo "")
              BRANCH_COVERAGE=$(xmllint --xpath "string(//report/counter[@type='BRANCH']/@missed)" "$COVERAGE_XML" 2>/dev/null || echo "")
              
              if [ -n "$LINE_COVERAGE" ]; then
                echo "coverage_available=true" >> "$GITHUB_OUTPUT"
                echo "Coverage report available in artifacts"
              else
                echo "coverage_available=false" >> "$GITHUB_OUTPUT"
              fi
            else
              echo "coverage_available=true" >> "$GITHUB_OUTPUT"
              echo "Coverage report available (xmllint not available for parsing)"
            fi
          else
            echo "coverage_available=false" >> "$GITHUB_OUTPUT"
            echo "‚ÑπÔ∏è Coverage report not found"
          fi

      - name: Prepare release files
        id: release_files
        run: |
          RELEASE_FILES="${{ steps.build.outputs.apk_path }}"
          
          # Add SHA256 checksum file
          if [ -n "${{ steps.build.outputs.sha256sum_path }}" ]; then
            RELEASE_FILES="${RELEASE_FILES}\n${{ steps.build.outputs.sha256sum_path }}"
            echo "‚úÖ SHA256 checksum file will be included in release"
          else
            echo "‚ö†Ô∏è Warning: SHA256 checksum file not available"
          fi
          
          # Add ProGuard mapping file if it exists
          if [ "${{ steps.proguard.outputs.mapping_exists }}" == "true" ] && [ -n "${{ steps.proguard.outputs.mapping_output }}" ]; then
            RELEASE_FILES="${RELEASE_FILES}\n${{ steps.proguard.outputs.mapping_output }}"
            echo "‚úÖ ProGuard mapping file will be included in release"
          else
            echo "‚ÑπÔ∏è ProGuard mapping file not available for this release"
          fi
          
          echo "files<<EOF" >> "$GITHUB_OUTPUT"
          echo -e "${RELEASE_FILES}" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Create GitHub release with APK
        uses: softprops/action-gh-release@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          tag_name: ${{ steps.version.outputs.tag }}
          name: ${{ steps.relmeta.outputs.release_name }}
          body: |
            ## Release ${{ steps.version.outputs.version }}
            
            **Build Number:** ${{ github.run_number }}  
            **Commit:** ${{ github.sha }}  
            **APK Size:** ${{ steps.build.outputs.apk_size }} bytes
            
            ${{ steps.relmeta.outputs.release_notes }}
            
            ---
            ### Build Artifacts
            - üì¶ APK: `${{ steps.build.outputs.apk_filename }}`
            - üîê SHA256: `${{ steps.build.outputs.sha256sum_filename }}` (Hash: `${{ steps.build.outputs.sha256_hash }}`)
            ${{ steps.proguard.outputs.mapping_exists == 'true' && format('- üìÑ ProGuard Mapping: `{0}`', steps.proguard.outputs.mapping_filename) || '' }}
            ${{ steps.coverage.outputs.coverage_available == 'true' && '- üìä Code Coverage: Available in workflow artifacts' || '' }}
            
            ---
            *Automated release build*
          draft: false
          prerelease: false
          files: ${{ steps.release_files.outputs.files }}

      - name: Cleanup keystore
        if: always()  # P0: Always cleanup, even on failure
        run: |
          # P0: Securely remove keystore file
          if [ -f "app/keystore.jks" ]; then
            echo "Cleaning up keystore file..."
            # P0: Overwrite with zeros before deletion (security best practice)
            # Use dd to overwrite file content, then remove
            if command -v shred > /dev/null 2>&1; then
              shred -u -z app/keystore.jks
            else
              # Fallback: overwrite with zeros using dd, then remove
              dd if=/dev/zero of=app/keystore.jks bs=1M count=1 2>/dev/null || true
              rm -f app/keystore.jks
            fi
            echo "Keystore cleaned up successfully"
          fi
          
          # P0: Verify keystore is removed
          if [ -f "app/keystore.jks" ]; then
            echo "Error: Keystore file still exists after cleanup"
            exit 1
          fi
